leetcode
========
08/18

    Unique Paths
    应该是简单的数学排列组合问题，提炼一下其实就一句话：有m个黑球，n个白球，有多少种不同的排列方式。
    我数学太差，没找到答案，直接上了动态规划。
    Unique Paths II
    mod之后，可能数学公式就不能简单地给出答案了。但对我来说，其实和前一题没区别。动态规划处理这种问题，早就是牛刀杀鸡了。。
    Single Number
    碰巧我知道异或的解法。如果不知道的话，想想还是有点费事的。
    Maximum Depth of Binary Tree
    这？也太简单了吧。。一行代码，一个尾递归搞定啊。。

终于想清楚了，leetcode的AC率应该是：在线编辑、肉眼检查，提交的准确率！借助线下debug工具，有何难度可言？丝毫没有模拟在线面试的味道了。。另外，时间也是个考核要素，但考虑到实际情况，感觉通常只要被面试者没有放弃，在合理的时间内，一般都可以继续，所以先这样吧。。
08/19

    Same Tree
    这种简单的二叉树遍历，丝毫没有难度啊。。
    Insertion Sort List
    在这里遇到前所未遇的惨败——提交了9次才搞定。。第9次提交的代码逻辑是OK的，但因为python的执行效率原因被拒。我又用C++把相同的逻辑翻译了一遍，第10次AC。。
    就这道题来说，虽然是简单到爆的算法书后练习题，不过原来没实际编写过的话，能力普通的一般人还是容易碰到坑。。
    记录一下几个要点：
        需要用到四个指针！
            一个在外循环中指向当前待比较的对象
            一个在已排序的内循环中，指向迭代过程另一个比较对象
            一个用来记录外循环中，前一个列表对象——用来纠正指针指向
            一个用来记录内循环中，前一个迭代对象——用来纠正指针指向
        当待比较对象小于内循环迭代对象时，需要处理三个指针指向
            外循环前一个列表对象.next->外循环对象.next
            外循环对象.next->内循环迭代对象
            内循环前一个迭代对象.next->外循环对象 或 外循环对象成为头指针
        如果发生对象交换，外循环前一个对象指针不变。否则顺移
        优化方案：先对外循环中两个指针指向的对象进行比较。对于完全无序的一个单链表，仍然有50%的可能避免内循环操作，直接进行指针移动。对于极端情况：已升序排列单链表。则是把一个O(n^2)复杂度问题将为O(n)了。
    运行效率记录：2000个待排序元素。python: 1.5s左右， c++ 20ms左右。80倍

08/20

    Reverse Linked List II
    这题很简单，没啥好多说的。本来是above average的，不过有行python代码的缩进少了个空格，导致Runtime Error...残念。
    Copy List with Random Pointer
    这题我很不情愿地用了额外的hash来处理random指针，题目没什么太大难度，稍微小心点就可以。我第二次AC掉了

08/21

    Merge Two Sorted Lists
    无难度，一次AC
    Sort List
    要用nlog(n)复杂度解决单向链表的排序问题。而且要求常量的空间复杂度。
    考察几个经典的nlog(n)算法方案：
        快排
        算法主体是通过迭代完成的，可以符合单链表的场景。问题是random pivot的选取。leetcode不允许使用外部库，所以随机函数不好写。而没有random pivot，一定会被leetcode喂出来的极端情况（已排序链表）搞死的。。
        堆排序
        大根堆的下降过程中，包含大量根据数组下标进行的元素访问，非常不适合链表这种数据结构
        归并排序本来在处理数组时，需要额外线性空间复杂度。但应用在单链表场景中，却是出奇的好用（顺便借鉴了上题的代码，我是故意这么安排的，我会乱说么。）。相对数组所需的额外操作是，每次merge调用递归前，需要迭代到当前链表对象的length/2部位，为了定位另一个待迭代的链表指针。
    我本来第二次就AC掉了。妈蛋的python效率又掉链子，害我又用C++实现了遍提交搞定。看来以后nlog(n)复杂度的算法，也不能用python了——重写很烦人。两者的效率对比：3w的元素，python: 0.8s左右，c++: 20ms左右。40倍

    Remove Duplicates from Sorted List
    很没节操使用了hash，想知道有不使用额外数据结构的方法么？而且这么简单的逻辑，我还提交了两次，该打屁股了
    看了下别人的讨论，有用二重循环的。。好吧
    Remove Duplicates from Sorted List II
    边coding边思考，觉得难得一塌糊涂，一堆特殊情况要考虑，缩进都到了第8层，双重循环外加hash，模拟流程执行步骤，脑补得快吐血。没想到竟然一遍就通过了？！我没在做梦吧。
    Linked List Cycle
    很简单的题，头上几行判断的时候，心里面还在想：就算只有一个元素的情况，仍有可能出现循环。但到实际循环中，就忘记了。。今天写得有点累，扯旗走人。//btw，python又跪在O(n^2)了。。

08/21

    Linked List Cycle II
    反正我是没看出这题同之前那道有啥区别。这是第一个直接用cpp写的程序，提交，一遍AC掉。
    Linked List Cycle
    了解到这是一个经典的快慢指针问题。复杂度应该是O(n)。重新用python实现了遍。


08/22

    Remove Duplicates from Sorted List
    发现自己审题不清，没有注意到Sorted List这个限定条件，所以最后提交的，其实是针对一般链表的算法。
    对于已排序的链表，自然O(n) without extra space.. 一遍AC
    Remove Duplicates from Sorted List II
    同上。解决的也是一般问题——难怪当时实现得那么恶心。和上面那个差别还是不大，稍微留心一点就可以，也一遍过。

08/25

    Linked List Cycle II
    这个题（包括 I 部分）还是有点意思的，开篇另记了。见《单向链表的环检查与快慢指针》。想清楚就没有难度了，一遍AC。
    Remove Nth Node From End of List
    唉，也是看了讨论才知道one pass的方法，蠢人伤不起。。
    思路其实很简单：两个指针，第一个先往后移动n个节点，然后第二个指针指向头部（其实还差一位），两个指针开始一起移动。等第一个指针移动到链表尾部的时候，第二个指针指向待删除的元素——所以需要它前一位元素来改next指针。不过如果删除的正好是链表头部的第一个元素，还需要做些特殊处理，嗯。一遍AC
    Partition List
    其实就是实现快排中的partition部分。想想清楚还是比较简单的，也没什么要点。一遍AC

09/01

    Binary Tree Preorder Traversal
    无难度。
    Binary Tree Inorder Traversal
    提交了8次。。其实，前、中，后序遍历，概念讲讲很清楚，但原来没写过，会有些坑，特别是要求用迭代的方式。关键是进出栈的顺序控制，要想想清楚才行。
    Binary Tree Postorder Traversal
    这是用迭代方式实现的，三种深度优先访问顺序中，最为麻烦的一种访问顺序。需要一个lastnode指针，用以判断回溯节点是否可以访问。这个方法有必要回顾复习下。
    以上仨，参看wiki：http://en.wikipedia.org/wiki/Tree_traversal#Depth-first_2

    再说说关于DFS的三种访问：
        如果用递归实现，都是清一色的四句话：判断返回条件，然后排列当前节点的访问以及左右子树的递归的顺序。
        如果用迭代实现，就要麻烦得多。
            其中最简单的是Preorder：根节点压栈后进入循环体。循环体实现为：每次弹一个节点，访问，然后右孩子压栈，左孩子压栈，over。
            Inorder就开始出现了迭代的思想：循环体内，如果(if)当前访问节点非空，则将当前节点压栈，当前节点指向左孩子。否则(else)，弹一个节点，访问，当前节点指向右孩子。其中，深入想下就能明白，if-else就是安插在节点访问前后，迭代形式的递归过程。
            而相对最麻烦的就是Postorder，两个递归过程都在节点访问之前。。需要引入一个lastnode指针，每次访问一个节点之后，需要用lastnode指针作标记。左孩子的递归和中序保持一致。当弹栈的时候，需要判断右孩子存在并尚未访问——判断条件有两个：1.当前节点的右孩子是否存在 2.当前节点的右孩子和lastnode指针是否不相同。如果(if)成立的话，需要将当前节点再次压栈，然后当前节点指向右孩子。否则(else)， 说明右孩子不存在，或者已完成右孩子的迭代，访问当前节点。
    进阶问题：可以对三叉进行迭代访问么？如果是三叉的话，中序(Inorder)的提法就没有意义了。剩下的，前序应该还是一样简单，而后序的话，还要复杂的多吧。尽管我觉得这个没什么实际意义。

    Binary Tree Level Order Traversal
    二叉树的BFS，其实本来一个队列就ok。这题对收集数据格式有要求，多用了一个数组存放下一层节点。
    标准的做法是：http://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_2
     Binary Tree Level Order Traversal II
    。。。无语

09/02

    Binary Tree Zigzag Level Order Traversal
    题是很简单的题，不过一个细节没想清楚。第二次AC。
    Flatten Binary Tree to Linked List
    想了很长时间。一遍AC。看了Discus，发现别人有些很牛比的解法。貌似我现在会不加思索地使用栈来处理树的递归向迭代转化。而这可能不是唯一的做法吧

09/04

    Balanced Binary Tree
    花了一天多时间才搞定啊！！4次AC。
    因为当前阶段入了迭代的魔道，相对直观的递归做法就直接无视了——后来发现leetcode对该题的讨论帖，清一色都是递归方案，是不是可以小小地得意下呢？XD
    想清楚后，发现解法还是比较浅显易懂的：
    在后序遍历的基础上，回答当前访问节点是否平衡的问题。
    在后序遍历本身需要的节点栈之外，额外需要一个树高度栈，存放判断平衡的子树高度信息。
    对于当前访问节点的高度，可以通过计算节点栈中的压栈元素个数来得到——这是迭代后序访问的福利。
    对三种不同的节点区别对待：
        叶子节点。没有是否平衡的概念，直接压入树高度栈。
        对于只有一个孩子节点的中间节点，从树高度栈弹出一个树高度，如果这个出栈元素的高度和当前节点高度相差大于1，则发现不平衡。否则，把这个出栈树高度重新压栈
        对于有两个孩子节点的中间节点，从树高度栈弹出两个树高度，如果差值大于1，不平衡。否则，压入一个这两个高度之间的大值。

09/05

    Minimum Depth of Binary Tree
    5次AC。。题目是很简单的，不过我起初把它误翻译为：找第一个非全满层了，因而走了弯路。不过方法用的还是广度优先，也没有其它方法可以做了吧？

在做Convert Sorted List to Binary Search Tree，其实是个很经典的练习题了。我都没细想，就决定正儿八经通过旋转的方法，从头构建BST。失衡判断及旋转，偷了个懒，直接在迭代方式的Balanced Binary Tree基础上做了。其实呢，这个方法虽然也不能说不可取，但解决的其实是个在线算法。性能上，平衡判断（Balanced Binary Tree）的复杂度是O(n)，链表的每个元素都执行一次，所以复杂度就是O(n^2)了。。最后败在17000输入值上了。根据部分执行的运行结果来看，最后应该是用到10m以上的时间，惨不忍睹。。
看到leetcode大佬1337c0d3r的这段话，被棒喝了。。
" 
     Recursion is a very powerful problem-solving mechanism, and you would not go very far without it during an interview session.
"
唉，明天继续吧
09/10

    Validate Binary Search Tree
    我疑心应该有更好的做法吧，我的复杂是O(n)，而且还使用了O(n)的外部存储——中序遍历整个树，将节点数值存至数组。然后遍历这个值数组，如果不是单调递增，则返回False。
    看了下讨论，发现思路跟我是一致的：核心就是中序遍历。但完全没必要额外存储，只要记录上次访问的值变量，跟当前节点进行比较即可。修改了下，重新提交的执行时间并没有变化。。
    Symmetric Tree
    很简单：从根节点开始，对左右两棵子树同时进行先序遍历，逐一比对即可。我是用迭代实现的，所以在对两个孩子节点压栈的时候，左右两边的先后次序需要反过来。递归也是一样的。总而言之，还是比较简单的。

09/15

    Unique Binary Search Trees
    生成由{1..n}自然数构成的BST数量。用递归的思路来考虑：选取{1..n}之间的一个数，解设为k。根据BST的性质，我们知道k的左子树元素个数为k-1，右子树为n-k。只要把左右两个子树各自的BST数量做迪卡尔积，就可以得到以k作为根节点的BST的总数量。这是自然而然的递归思路，但要注意的是，这里的递归会分叉，从而会引起很多重复子问题被计算，如果用递归的方式則会效率不彰，所以最终的计算要以迭代的方式进行。假设函数名称为f，那么可以写出这样的迭代式：f(n)=2*f(n-1)+{sigma(i=1 -> n-2): f(i) * f(n-i-1)}。还是比较简单的，注意下下标越界的问题即可，一遍AC。

